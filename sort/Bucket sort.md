tags : #sort 

#### Introduction : 

Bucket sort assumes that the input is drawn form a uniform distribution and has am average case running time O(n). Bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval \[0, 1).

Bucket sort divides the interval \[0, 1) into n equal sized sub-intervals or buckets and then distributes the n input numbers into the bucket. Since the inputs are uniformly and independently distributed over \[0, 1), we do not expect many numbers to fall into each bucket. To produce the output, we sort the numbers in each bucket and then go through the bucket in order, listing elements in each.

#### Implementation : 

Following procedure assumes that the input is an n-element array *values* and that each element *values\[i]* in the array satisfies 0 <= *values\[i]* < 1. It uses auxiliary array *bucket\[0 ... n - 1]* of linked list.

```
public void bucketSort(int[] values) {
    int n = values.length;
    if (n <= 0) return;
    
	// Find max value to normalize the input
    int max = Arrays.stream(values).max().getAsInt();
    
	// Create empty buckets
    List<List<Integer>> buckets = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        buckets.add(new ArrayList<>());
    }
	
	// Distribute input values into buckets
    for (int value : values) {
        int index = (value * n) / (max + 1); // Normalized index
        buckets.get(index).add(value);
    }
    
    // Sort individual buckets using insertion sort
    for (List<Integer> bucket : buckets) {
        insertionSort(bucket);
    }
    
    // Concatenate buckets back into original array
    int index = 0;
    for (List<Integer> bucket : buckets) {
        for (int value : bucket) {
            values[index++] = value;
        }
    }
}
```

**Time Complexity** : O(n) where 'n' is length ofÂ _values_.
